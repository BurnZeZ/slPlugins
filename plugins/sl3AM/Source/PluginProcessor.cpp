/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

#include <cmath>

#define NUM_HARMONICS   10

//==============================================================================
class ThreeAMSound : public SynthesiserSound
{
public:
    ThreeAMSound() {}
    
    bool appliesToNote (int /*midiNoteNumber*/) override  { return true; }
    bool appliesToChannel (int /*midiChannel*/) override  { return true; }
};

//==============================================================================
class ThreeAMVoice  : public SynthesiserVoice
{
public:
    ThreeAMVoice()
      : tailOff (0.0)
    {
        memset (angleDelta, 0, sizeof (angleDelta));
    }
    
    bool canPlaySound (SynthesiserSound* sound) override
    {
        return dynamic_cast<ThreeAMSound*> (sound) != nullptr;
    }
    
    void startNote (int midiNoteNumber, float velocity,
                    SynthesiserSound* /*sound*/,
                    int /*currentPitchWheelPosition*/) override
    {
        level = velocity * 0.15;
        tailOff = 0.0;
        
        for (int i = 0; i < NUM_HARMONICS; i++)
        {
            currentAngle[i] = 0.0;
        
            double cyclesPerSecond = MidiMessage::getMidiNoteInHertz (midiNoteNumber) * (i + 1);
            double cyclesPerSample = cyclesPerSecond / getSampleRate();
            
            angleDelta[i] = cyclesPerSample * 2.0 * double_Pi;
        }
    }
    
    void stopNote (float /*velocity*/, bool allowTailOff) override
    {
        if (allowTailOff)
        {
            // start a tail-off by setting this flag. The render callback will pick up on
            // this and do a fade out, calling clearCurrentNote() when it's finished.
            
            if (tailOff == 0.0) // we only need to begin a tail-off if it's not already doing so - the
                // stopNote method could be called more than once.
                tailOff = 1.0;
        }
        else
        {
            // we're being told to stop playing immediately, so reset everything..
            
            clearCurrentNote();
            angleDelta[0] = 0.0;
        }
    }
    
    void pitchWheelMoved (int /*newValue*/) override
    {
        // can't be bothered implementing this for the demo!
    }
    
    void controllerMoved (int /*controllerNumber*/, int /*newValue*/) override
    {
        // not interested in controllers in this case.
    }
    
    void renderNextBlock (AudioBuffer<float>& outputBuffer, int startSample, int numSamples) override
    {
        processBlock (outputBuffer, startSample, numSamples);
    }
    
    void renderNextBlock (AudioBuffer<double>& outputBuffer, int startSample, int numSamples) override
    {
        processBlock (outputBuffer, startSample, numSamples);
    }
    
private:
    
    template <typename FloatType>
    void processBlock (AudioBuffer<FloatType>& outputBuffer, int startSample, int numSamples)
    {
        if (angleDelta[0] != 0.0)
        {
            if (tailOff > 0)
            {
                while (--numSamples >= 0)
                {
                    for (int i = 0; i < NUM_HARMONICS; i++)
                    {
                        const FloatType currentSample = static_cast<FloatType> (std::sin (currentAngle[i]) * level * tailOff);
                        
                        for (int i = outputBuffer.getNumChannels(); --i >= 0;)
                            outputBuffer.addSample (i, startSample, currentSample);
                        
                        currentAngle[i] += angleDelta[i];
                    }
                    ++startSample;
                    
                    tailOff *= 0.99;
                    
                    if (tailOff <= 0.005)
                    {
                        clearCurrentNote();
                        
                        angleDelta[0] = 0.0;
                        break;
                    }
                }
            }
            else
            {
                while (--numSamples >= 0)
                {
                    for (int i = 0; i < NUM_HARMONICS; i++)
                    {
                        const FloatType currentSample = static_cast<FloatType> (std::sin (currentAngle[i]) * level);
                        
                        for (int i = outputBuffer.getNumChannels(); --i >= 0;)
                            outputBuffer.addSample (i, startSample, currentSample);
                        
                        currentAngle[i] += angleDelta[i];
                    }
                    ++startSample;
                }
            }
        }
    }
    
    double currentAngle[NUM_HARMONICS], angleDelta[NUM_HARMONICS], level, tailOff;
};

//==============================================================================
sl3AMAudioProcessor::sl3AMAudioProcessor()
{
    addPluginParameter (new slParameter (PARAM_ENABLE,       "Enable",       "",     0.0f,      1.0f, 1.0f,    1.0f, 1.0f));
    
    synth = new Synthesiser();

    for (int i = 0; i < 8; i++)
        synth->addVoice (new ThreeAMVoice());
    
    synth->addSound (new ThreeAMSound());
}

sl3AMAudioProcessor::~sl3AMAudioProcessor()
{
}

//==============================================================================
void sl3AMAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    synth->setCurrentPlaybackSampleRate (sampleRate);
}

void sl3AMAudioProcessor::releaseResources()
{
}

void sl3AMAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    enableVal.setValue (getParameter (PARAM_ENABLE)->getUserValue());
    
    synth->renderNextBlock (buffer, midi, 0, buffer.getNumSamples());
    
    applyGain (buffer, enableVal);
    
    outputLevel.trackBuffer (buffer);
}

//==============================================================================
bool sl3AMAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* sl3AMAudioProcessor::createEditor()
{
    return new sl3AMAudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new sl3AMAudioProcessor();
}
