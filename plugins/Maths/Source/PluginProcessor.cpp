/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

using namespace gin;

//==============================================================================
MathsAudioProcessor::MathsAudioProcessor()
{
    addPluginParameter (new Parameter (PARAM_P1,       "p1 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P2,       "p2 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P3,       "p3 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P4,       "p4 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_LIMITER,  "Limiter",         "", "",      0.0f,  1.0f,  1.0f,    1.0f,    1.0f,    [] (const Parameter&, float v) { return v > 0.5 ? "On" : "Off"; }));

    setupParsers();
}

MathsAudioProcessor::~MathsAudioProcessor()
{
}

//==============================================================================
void MathsAudioProcessor::stateUpdated()
{
    lEquation = state.hasProperty ("l") ? state.getProperty ("l") : "(l + r) / 2";
    rEquation = state.hasProperty ("r") ? state.getProperty ("r") : "(l + r) / 2";
   
    setupParsers();
    
    if (editor != nullptr)
        editor->refresh();
}

void MathsAudioProcessor::updateState()
{
    state.setProperty ("l", lEquation, nullptr);
    state.setProperty ("r", rEquation, nullptr);
}

//==============================================================================
void MathsAudioProcessor::prepareToPlay (double sampleRate, int)
{
    if (lParser != nullptr) lParser->setSampleRate (sampleRate);
    if (rParser != nullptr) rParser->setSampleRate (sampleRate);

    sr = sampleRate;
    c = -1;
    s = 0;
    t = 0;
    
    p1Val.reset (sampleRate, 0.1);
    p2Val.reset (sampleRate, 0.1);
    p3Val.reset (sampleRate, 0.1);
    p4Val.reset (sampleRate, 0.1);
}

void MathsAudioProcessor::setupParsers()
{
    auto csr = getSampleRate();
    if (csr == 0) csr = 44100.0;
    
    auto newL = std::make_unique<AudioEquationParser>();
    auto newR = std::make_unique<AudioEquationParser>();
    
    newL->setSampleRate (csr);
    newL->addConstants();
    newL->addEffectFilterFunctions();
    newL->setEquation (lEquation);
    setupVars (*newL);
    newL->evaluate();

    newR->setSampleRate (csr);
    newR->addConstants();
    newR->addEffectFilterFunctions();
    newR->setEquation (rEquation);
    setupVars (*newR);
    newR->evaluate();

    {
        ScopedLock sl (lock);
        
        std::swap (lParser, newL);
        std::swap (rParser, newR);
    }
}

void MathsAudioProcessor::setupVars (gin::EquationParser& p)
{
    p.addVariable ("l", &l);
    p.addVariable ("r", &r);
    p.addVariable ("p1", &p1);
    p.addVariable ("p2", &p2);
    p.addVariable ("p3", &p3);
    p.addVariable ("p4", &p4);
    p.addVariable ("t", &t);
    p.addVariable ("s", &s);
    p.addVariable ("c", &c);
    p.addVariable ("sr", &sr);
}

void MathsAudioProcessor::releaseResources()
{
}

void MathsAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer&)
{
    ScopedLock sl (lock);
    
    ScopedNoDenormals noDenormals;
    
    float* lData = buffer.getWritePointer (0);
    float* rData = buffer.getWritePointer (1);
    
    p1Val.setTargetValue (parameterValue (PARAM_P1));
    p2Val.setTargetValue (parameterValue (PARAM_P2));
    p3Val.setTargetValue (parameterValue (PARAM_P3));
    p4Val.setTargetValue (parameterValue (PARAM_P4));

    if (auto p = getPlayHead())
    {
        AudioPlayHead::CurrentPositionInfo pos;
        if (p->getCurrentPosition (pos))
        {
            c = pos.timeInSeconds;
        }
    }

    for (int i = 0; i < buffer.getNumSamples(); i++)
    {
        l = lData[i];
        r = rData[i];
        
        p1 = p1Val.getNextValue();
        p2 = p2Val.getNextValue();
        p3 = p3Val.getNextValue();
        p4 = p4Val.getNextValue();

        double l2 = lParser->evaluate();
        double r2 = rParser->evaluate();
        
        if (std::isnan (l2) || std::isinf (l2)) l2 = 0.0f;
        if (std::isnan (r2) || std::isinf (r2)) r2 = 0.0f;
        
        if (parameterIntValue (PARAM_LIMITER) != 0)
        {
            l2 = jlimit (-1.0, 1.0, l2);
            r2 = jlimit (-1.0, 1.0, r2);
        }
        
        lData[i] = float (l2);
        rData[i] = float (r2);
        
        if (c != -1) c = 1 / sr;
        t += 1 / sr;
        s++;
    }
}

//==============================================================================
bool MathsAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* MathsAudioProcessor::createEditor()
{
    editor = new MathsAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MathsAudioProcessor();
}
