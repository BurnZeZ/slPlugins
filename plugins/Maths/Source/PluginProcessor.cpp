/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

using namespace gin;

//==============================================================================
MathsAudioProcessor::MathsAudioProcessor()
{
    addPluginParameter (new Parameter (PARAM_P1,       "p1 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P2,       "p2 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P3,       "p3 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P4,       "p4 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_LIMITER,  "Limiter",         "", "",      0.0f,  1.0f,  1.0f,    1.0f,    1.0f,    [] (const Parameter&, float v) { return v > 0.5 ? "On" : "Off"; }));

    setupParsers();
}

MathsAudioProcessor::~MathsAudioProcessor()
{
}

//==============================================================================
void MathsAudioProcessor::stateUpdated()
{
    lEquation = state.hasProperty ("l") ? state.getProperty ("l") : "(l + r) / 2";
    rEquation = state.hasProperty ("r") ? state.getProperty ("r") : "(l + r) / 2";
   
    setupParsers();
    
    if (editor != nullptr)
        editor->refresh();
}

void MathsAudioProcessor::updateState()
{
    state.setProperty ("l", lEquation, nullptr);
    state.setProperty ("r", rEquation, nullptr);
}

//==============================================================================
void MathsAudioProcessor::prepareToPlay (double sampleRate, int)
{
    if (lParser != nullptr) lParser->setSampleRate (sampleRate);
    if (rParser != nullptr) rParser->setSampleRate (sampleRate);

    sr = sampleRate;
    c = -1;
    s = 0;
    t = 0;
    
    p1Val.reset (sampleRate, 0.1);
    p2Val.reset (sampleRate, 0.1);
    p3Val.reset (sampleRate, 0.1);
    p4Val.reset (sampleRate, 0.1);
    
    memset (li, 0, sizeof (li));
    memset (ri, 0, sizeof (ri));
    memset (lo, 0, sizeof (lo));
    memset (ro, 0, sizeof (ro));
}

void MathsAudioProcessor::setupParsers()
{
    auto csr = getSampleRate();
    if (csr == 0) csr = 44100.0;
    
    auto newL = std::make_unique<AudioEquationParser>();
    auto newR = std::make_unique<AudioEquationParser>();
    
    newL->setSampleRate (csr);
    newL->addConstants();
    newL->addEffectFilterFunctions();
    newL->setEquation (lEquation);
    setupVars (*newL);
    newL->evaluate();
    
    if (newL->hasError())
    {
        lError = newL->getError();
        DBG(lError);
        newL = nullptr;
    }
    else
    {
        lError = {};
    }

    newR->setSampleRate (csr);
    newR->addConstants();
    newR->addEffectFilterFunctions();
    newR->setEquation (rEquation);
    setupVars (*newR);
    newR->evaluate();
    
    if (newR->hasError())
    {
        rError = newR->getError();
        DBG(rError);
        newR = nullptr;
    }
    else
    {
        rError = {};
    }

    {
        ScopedLock sl (lock);
        
        std::swap (lParser, newL);
        std::swap (rParser, newR);
    }
}

void MathsAudioProcessor::setupVars (gin::EquationParser& p)
{
    p.addVariable ("l", &l);
    p.addVariable ("r", &r);
    p.addVariable ("p1", &p1);
    p.addVariable ("p2", &p2);
    p.addVariable ("p3", &p3);
    p.addVariable ("p4", &p4);
    p.addVariable ("t", &t);
    p.addVariable ("s", &s);
    p.addVariable ("c", &c);
    p.addVariable ("sr", &sr);
    
    for (int i = 0; i < 256; i++)
    {
        p.addVariable (String::formatted ("li%d", i), &li[i]);
        p.addVariable (String::formatted ("ri%d", i), &ri[i]);
        p.addVariable (String::formatted ("lo%d", i), &lo[i]);
        p.addVariable (String::formatted ("ro%d", i), &ro[i]);
    }
}

void MathsAudioProcessor::releaseResources()
{
}

void MathsAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer&)
{
    ScopedLock sl (lock);
    
    ScopedNoDenormals noDenormals;
    
    float* lData = buffer.getWritePointer (0);
    float* rData = buffer.getWritePointer (1);
    
    p1Val.setTargetValue (parameterValue (PARAM_P1));
    p2Val.setTargetValue (parameterValue (PARAM_P2));
    p3Val.setTargetValue (parameterValue (PARAM_P3));
    p4Val.setTargetValue (parameterValue (PARAM_P4));

    if (auto p = getPlayHead())
    {
        AudioPlayHead::CurrentPositionInfo pos;
        if (p->getCurrentPosition (pos))
        {
            c = pos.timeInSeconds;
        }
    }

    for (int i = 0; i < buffer.getNumSamples(); i++)
    {
        l = lData[i];
        r = rData[i];
        
        memmove (li + 1, li, (size_t) (numElementsInArray (li) - 1) * sizeof (double));
        memmove (ri + 1, ri, (size_t) (numElementsInArray (ri) - 1) * sizeof (double));
        memmove (lo + 1, lo, (size_t) (numElementsInArray (lo) - 1) * sizeof (double));
        memmove (ro + 1, ro, (size_t) (numElementsInArray (ro) - 1) * sizeof (double));
        
        li[0] = l;
        ri[0] = r;
        lo[0] = 0;
        ro[0] = 0;

        p1 = p1Val.getNextValue();
        p2 = p2Val.getNextValue();
        p3 = p3Val.getNextValue();
        p4 = p4Val.getNextValue();

        double l2 = (lParser != nullptr) ? lParser->evaluate() : 0.0;
        double r2 = (rParser != nullptr) ? rParser->evaluate() : 0.0;
        
        if (std::isnan (l2) || std::isinf (l2)) l2 = 0.0f;
        if (std::isnan (r2) || std::isinf (r2)) r2 = 0.0f;
        
        if (parameterIntValue (PARAM_LIMITER) != 0)
        {
            l2 = jlimit (-1.0, 1.0, l2);
            r2 = jlimit (-1.0, 1.0, r2);
        }
        
        lData[i] = float (l2);
        rData[i] = float (r2);
        
        lo[0] = l2;
        ro[0] = r2;
        
        if (c != -1) c = 1 / sr;
        t += 1 / sr;
        s++;
    }
}

//==============================================================================
bool MathsAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* MathsAudioProcessor::createEditor()
{
    editor = new MathsAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MathsAudioProcessor();
}
