/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

using namespace gin;

//==============================================================================
FormulaAudioProcessor::FormulaAudioProcessor()
{
    formulaSynth.setMPE (false);
    
    addPluginParameter (new gin::Parameter (PARAM_OSC1_ENABLE,  "OSC 1 Enable",         "OSC1", "",      0.0f,   1.0f,   1.0f,    1.0f));
    addPluginParameter (new gin::Parameter (PARAM_OSC2_ENABLE,  "OSC 2 Enable",         "OSC2", "",      0.0f,   1.0f,   1.0f,    0.0f));
    addPluginParameter (new gin::Parameter (PARAM_OSC3_ENABLE,  "OSC 3 Enable",         "OSC3", "",      0.0f,   1.0f,   1.0f,    0.0f));
    
    addPluginParameter (new gin::Parameter (PARAM_ATTACK,       "Attack",               "A",    "s",     0.001f,   60.0f,  0.0f,    0.1f, 0.2f));
    addPluginParameter (new gin::Parameter (PARAM_DECAY,        "Decay",                "D",    "s",     0.001f,   60.0f,  0.0f,    0.1f, 0.2f));
    addPluginParameter (new gin::Parameter (PARAM_SUSTAIN,      "Sustain",              "S",    "%",     0.0f,     1.0f,   0.0f,    0.8f, 1.0f));
    addPluginParameter (new gin::Parameter (PARAM_RELEASE,      "Release",              "R",    "s",     0.001f,   60.0f,  0.0f,    0.1f, 0.2f));
    addPluginParameter (new gin::Parameter (PARAM_VELOCITY,     "Velocity",             "",     "",      0.0f,     1.0f,   0.0f,    1.0f, 1.0f));

    addPluginParameter (new gin::Parameter (PARAM_FLT_FREQ,     "Cutoff",               "",     "Hz",    0.0f,   135.076232f,  0.0f, 69.0f, 1.0f, [](const gin::Parameter&, float v) { return String (gin::getMidiNoteInHertz (v)); }));
    addPluginParameter (new gin::Parameter (PARAM_FLT_RES,      "Resonance",            "Res",  "%",     0.0f,   100.0f, 0.0f,    0.0f, 1.0f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_AMOUNT,   "Env Amount",           "Env",  "",     -1.0f,   1.0f,   0.0f,    0.0f, 1.0f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_KEY,      "Key tracking",         "Key",  "%",     0.0f,   100.0f, 0.0f,    0.0f, 1.0f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_VELOCITY, "Velocity Tracking",    "Vel",  "%",     0.0f,   100.0f, 0.0f,    0.0f, 1.0f));
    
    addPluginParameter (new gin::Parameter (PARAM_FLT_ATTACK,   "Attack",               "A",    "s",     0.0f,   60.0f,  0.0f,    0.1f, 0.2f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_DECAY,    "Decay",                "D",    "s",     0.0f,   60.0f,  0.0f,    0.1f, 0.2f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_SUSTAIN,  "Sustain",              "S",    "%",     0.0f,   1.0f,   0.0f,    0.8f, 1.0f));
    addPluginParameter (new gin::Parameter (PARAM_FLT_RELEASE,  "Release",              "R",    "s",     0.0f,   60.0f,  0.0f,    0.1f, 0.2f));

    formulas[0] = "lp(saw(note), cutoff, res) * env";
    formulas[1] = "lp(triangle(note), cutoff, res) * env";
    formulas[2] = "lp(square(note), cutoff, res) * env";
    
    refreshFormulas();
}

FormulaAudioProcessor::~FormulaAudioProcessor()
{
}

//==============================================================================
String FormulaAudioProcessor::getOscFormula (int idx)
{
    return formulas[idx];
}

void FormulaAudioProcessor::setOscFormula (int idx, String formula)
{
    formulas[idx] = formula;
    refreshFormulas();
}

//==============================================================================
void FormulaAudioProcessor::refreshFormulas()
{
    formulaSynth.setFormulas (formulas[0], formulas[1], formulas[2]);
}

void FormulaAudioProcessor::stateUpdated()
{
    formulas[0] = state.hasProperty ("f1") ? state.getProperty ("f1") : "lp(saw(note), cutoff, res) * env";
    formulas[1] = state.hasProperty ("f2") ? state.getProperty ("f2") : "lp(triangle(note), cutoff, res) * env";
    formulas[2] = state.hasProperty ("f3") ? state.getProperty ("f3") : "lp(square(note), cutoff, res) * env";

    refreshFormulas();
    
    if (editor != nullptr)
        editor->refresh();
}

void FormulaAudioProcessor::updateState()
{
    state.setProperty ("f1", formulas[0], nullptr);
    state.setProperty ("f2", formulas[1], nullptr);
    state.setProperty ("f3", formulas[2], nullptr);
}

//==============================================================================
void FormulaAudioProcessor::prepareToPlay (double sampleRate, int /*samplesPerBlock*/)
{
    formulaSynth.setCurrentPlaybackSampleRate (sampleRate);
}

void FormulaAudioProcessor::releaseResources()
{
}

void FormulaAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    const int numSamples = buffer.getNumSamples();

    auto& params = formulaSynth.getParams();
    params.osc1enable       = parameterBoolValue (PARAM_OSC1_ENABLE);
    params.osc2enable       = parameterBoolValue (PARAM_OSC2_ENABLE);
    params.osc3enable       = parameterBoolValue (PARAM_OSC3_ENABLE);
    
    params.ampAttack        = parameterValue (PARAM_ATTACK);
    params.ampDecay         = parameterValue (PARAM_DECAY);
    params.ampSustain       = parameterValue (PARAM_SUSTAIN);
    params.ampRelease       = parameterValue (PARAM_RELEASE);
    params.ampVelocity      = parameterValue (PARAM_VELOCITY);

    params.filterAttack     = parameterValue (PARAM_FLT_ATTACK);
    params.filterDecay      = parameterValue (PARAM_FLT_DECAY);
    params.filterSustain    = parameterValue (PARAM_FLT_SUSTAIN);
    params.filterRelease    = parameterValue (PARAM_FLT_RELEASE);

    params.filterKey        = parameterValue (PARAM_FLT_KEY);
    params.filterRes        = parameterValue (PARAM_FLT_RES);
    params.filterFreq       = parameterValue (PARAM_FLT_FREQ);
    params.filterAmount     = parameterValue (PARAM_FLT_AMOUNT);
    params.filterVelocity   = parameterValue (PARAM_FLT_VELOCITY);
    
    formulaSynth.renderNextBlock (buffer, midi, 0, numSamples);
    
    if (editor)
    {
        AudioSampleBuffer outputBuffer (buffer.getArrayOfWritePointers(), 2, numSamples);        
        editor->scope.addSamples (outputBuffer);
    }
}

//==============================================================================
bool FormulaAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* FormulaAudioProcessor::createEditor()
{
    editor = new FormulaAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new FormulaAudioProcessor();
}
