/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

//==============================================================================
String onOffTextFunction (const slParameter& p, float v)
{
    return v > 0.0f ? "On" : "Off";
}

//==============================================================================
slToneAudioProcessor::slToneAudioProcessor()
{
    //==============================================================================
    auto sineFunc = [&] (float in) -> float
    {
        return sin (in);
    };
    
    auto triangleFunc = [&] (float in) -> float
    {
        if (bandLimited)
        {
            double sum = 0;
            for (int k = 0; k < 30; k++)
            {
                int n = 2 * k + 1;
                sum += pow (-1, k) * pow (n, -2) * sin (std::abs (n * in / (2 * float_Pi)));
            }
            return sum;
        }
        return (in < 0 ? in / -float_Pi : in / float_Pi) * 2 - 1;
    };
    
    auto sawUpFunc = [&] (float in) -> float
    {
        if (bandLimited)
        {
            double f = parameterValue (PARAM_FREQ);
            
            double sum = 0;
            int k = 1;
            while (f * k < getSampleRate() / 2)
            {
                sum += std::pow (-1, k) * sin (k * in) / k;
                k++;
            }
            return -1.0f / float_Pi * sum;
        }
        return ((in + float_Pi) / (2 * float_Pi)) * 2 - 1;
    };
    
    auto sawDownFunc = [&] (float in) -> float
    {
        if (bandLimited)
        {
            double f = parameterValue (PARAM_FREQ);
            
            double sum = 0;
            int k = 1;
            while (f * k < getSampleRate() / 2)
            {
                sum += std::pow (-1, k) * sin (k * in) / k;
                k++;
            }
            return 2.0f / float_Pi * sum;
        }
        return -(((in + float_Pi) / (2 * float_Pi)) * 2 - 1);
    };
    
    auto squareFunc = [&] (float in) -> float
    {
        if (bandLimited)
        {
            double f = parameterValue (PARAM_FREQ);
            
            double sum = 0;
            int i = 1;
            while (f * (2 * i - 1) < getSampleRate() / 2)
            {
                sum += sin ((2 * i - 1) * in) / ((2 * i - 1));
                i++;
            }
            
            return 4.0f / float_Pi * sum;
        }
        return in < 0 ? -1 : 1;
    };
    
    auto noiseFunc = [&] (float) -> float
    {
        const float mean = 0.0;
        const float stddev = 0.1;
        
        static std::default_random_engine generator;
        static std::normal_distribution<float> dist (mean, stddev);
        
        return dist (generator);
    };
    
    sine.initialise (sineFunc);
    triangle.initialise (triangleFunc);
    sawUp.initialise (sawUpFunc);
    sawDown.initialise (sawDownFunc);
    square.initialise (squareFunc);
    noise.initialise (noiseFunc);

    //==============================================================================
    
    addPluginParameter (new slParameter (PARAM_ENABLE,       "Enable",       "", "",     0.0f,      1.0f, 1.0f,    1.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (PARAM_FREQ,         "Frequency",    "", "Hz",   30.0f, 10000.0f, 0.0f, 1000.0f, 0.5f));
    addPluginParameter (new slParameter (PARAM_SINE_LEVEL,   "Sine",         "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
    addPluginParameter (new slParameter (PARAM_TRI_LEVEL,    "Triangle",     "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
    addPluginParameter (new slParameter (PARAM_SAW_UP_LEVEL, "Saw Up",       "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
    addPluginParameter (new slParameter (PARAM_SAW_DN_LEVEL, "Saw Down",     "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
    addPluginParameter (new slParameter (PARAM_SQUARE_LEVEL, "Square",       "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
    addPluginParameter (new slParameter (PARAM_NOISE_LEVEL,  "Noise",        "", "dB", -100.0f,     6.0f, 0.0f, -100.0f, 5.f));
}

slToneAudioProcessor::~slToneAudioProcessor()
{
}

//==============================================================================
void slToneAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    scratch.setSize (1, samplesPerBlock);
    
    sine.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    triangle.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    sawUp.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    sawDown.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    square.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    noise.prepare ({ sampleRate, uint32 (samplesPerBlock), 1});
    
    enableVal.reset (sampleRate, 0.05);
    sineVal.reset (sampleRate, 0.05);
    triangleVal.reset (sampleRate, 0.05);
    sawUpVal.reset (sampleRate, 0.05);
    sawDownVal.reset (sampleRate, 0.05);
    squareVal.reset (sampleRate, 0.05);
    noiseVal.reset (sampleRate, 0.05);
}

void slToneAudioProcessor::releaseResources()
{
}

void slToneAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer&)
{
    int numSamples = buffer.getNumSamples();
    scratch.setSize (1, numSamples, false, false, true);
    
    float freq = getParameter (PARAM_FREQ)->getUserValue();
    
    sine.setFrequency (freq);
    triangle.setFrequency (freq);
    sawUp.setFrequency (freq);
    sawDown.setFrequency (freq);
    square.setFrequency (freq);

    enableVal.setValue (getParameter (PARAM_ENABLE)->getUserValue());
    sineVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_SINE_LEVEL)->getUserValue()));
    triangleVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_TRI_LEVEL)->getUserValue()));
    sawUpVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_SAW_UP_LEVEL)->getUserValue()));
    sawDownVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_SAW_DN_LEVEL)->getUserValue()));
    squareVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_SQUARE_LEVEL)->getUserValue()));
    noiseVal.setValue (Decibels::decibelsToGain (getParameter (PARAM_NOISE_LEVEL)->getUserValue()));

    AudioBlock<float> block (scratch);
    
    sine.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, sineVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);
    
    triangle.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, triangleVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);
    
    sawUp.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, sawUpVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);

    sawDown.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, sawDownVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);

    square.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, squareVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);
    
    noise.process (ProcessContextReplacing<float> (block));
    applyGain (scratch, noiseVal);
    buffer.addFrom (0, 0, scratch, 0, 0, numSamples);
    
    applyGain (buffer, enableVal);
    
    if (editor)
        editor->scope.addSamples (buffer.getReadPointer (0), buffer.getNumSamples());
}

//==============================================================================
bool slToneAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* slToneAudioProcessor::createEditor()
{
    editor = new slToneAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new slToneAudioProcessor();
}
