/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

using namespace cycfi::q;
using namespace cycfi::q::literals;
using namespace cycfi::q::notes;

constexpr frequency low_e          = E[0];
constexpr frequency high_e         = E[7];

//==============================================================================
PitchTrackAudioProcessor::PitchTrackAudioProcessor()
{
}

PitchTrackAudioProcessor::~PitchTrackAudioProcessor()
{
}

//==============================================================================
void PitchTrackAudioProcessor::prepareToPlay (double sampleRate_, int)
{
    freq = 0.0f;
    
    auto sc_conf = signal_conditioner::config {};

    conditioner = std::make_unique<signal_conditioner> ( sc_conf, low_e, high_e, uint32_t ( sampleRate_ ) );
    detector = std::make_unique<pitch_detector> (low_e, high_e, sampleRate_, -45_dB);
}

void PitchTrackAudioProcessor::releaseResources()
{
}

void PitchTrackAudioProcessor::processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer&)
{
    auto& d = *detector;
    auto& c = *conditioner;

    if (buffer.getNumChannels() == 1)
    {
        auto p = buffer.getReadPointer (0);
        for (int i = 0; i < buffer.getNumSamples(); i++)
        {
            auto v = p[i];
            v = c (v);
            if (d (v))
                freq = detector->get_frequency();
        }
    }
    else
    {
        auto l = buffer.getReadPointer (0);
        auto r = buffer.getReadPointer (1);
        
        for (int i = 0; i < buffer.getNumSamples(); i++)
        {
            auto v = (l[i] + r[i]) / 2.0f;
            v = c (v);
            if (d (v))
                freq = detector->get_frequency();
        }
    }
}

float PitchTrackAudioProcessor::getPitch()
{
    return freq;
}

//==============================================================================
bool PitchTrackAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* PitchTrackAudioProcessor::createEditor()
{
    return new PitchTrackAudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PitchTrackAudioProcessor();
}
