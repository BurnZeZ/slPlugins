/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <random>

using namespace gin;

//==============================================================================
MathsAudioProcessor::MathsAudioProcessor()
{
    addPluginParameter (new Parameter (PARAM_P1,       "p1 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P2,       "p2 (0..1)",       "", "",     0.0f,   1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P3,       "p3 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));
    addPluginParameter (new Parameter (PARAM_P4,       "p4 (-1..1)",      "", "",     -1.0f,  1.0f,  0.0f,    1.0f));

    setupParsers();
}

MathsAudioProcessor::~MathsAudioProcessor()
{
}

//==============================================================================
void MathsAudioProcessor::stateUpdated()
{
    lEquation = state.hasProperty ("l") ? state.getProperty ("l") : "(l + r) / 2";
    rEquation = state.hasProperty ("r") ? state.getProperty ("r") : "(l + r) / 2";
   
    setupParsers();
    
    if (editor != nullptr)
        editor->refresh();
}

void MathsAudioProcessor::updateState()
{
    state.setProperty ("l", lEquation, nullptr);
    state.setProperty ("r", rEquation, nullptr);
}

//==============================================================================
void MathsAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    sr = sampleRate;
    c = -1;
    s = 0;
    t = 0;
    
    p1Val.reset (sampleRate, 0.1);
    p2Val.reset (sampleRate, 0.1);
    p3Val.reset (sampleRate, 0.1);
    p4Val.reset (sampleRate, 0.1);
}

void MathsAudioProcessor::setupParsers()
{
    auto* newL = new EquationParser();
    auto* newR = new EquationParser();

    newL->setEquation (lEquation);
    newR->setEquation (rEquation);

    newL->addVariable ("l", &l);
    newL->addVariable ("r", &r);
    newL->addVariable ("p1", &p1);
    newL->addVariable ("p2", &p2);
    newL->addVariable ("p3", &p3);
    newL->addVariable ("p4", &p4);
    newL->addVariable ("t", &t);
    newL->addVariable ("s", &s);
    newL->addVariable ("c", &c);
    newL->addVariable ("sr", &sr);
    newR->addVariable ("l", &l);
    newR->addVariable ("r", &r);
    newR->addVariable ("p1", &p1);
    newR->addVariable ("p2", &p2);
    newR->addVariable ("p3", &p3);
    newR->addVariable ("p4", &p4);
    newR->addVariable ("t", &t);
    newR->addVariable ("s", &s);
    newR->addVariable ("c", &c);
    newR->addVariable ("sr", &sr);
    
    ScopedLock sl (lock);
    
    lParser = newL;
    rParser = newR;
}

void MathsAudioProcessor::releaseResources()
{
}

void MathsAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer&)
{
    ScopedLock sl (lock);
    
    ScopedNoDenormals noDenormals;
    
    float* lData = buffer.getWritePointer (0);
    float* rData = buffer.getWritePointer (1);
    
    p1Val.setValue (parameterValue (PARAM_P1));
    p2Val.setValue (parameterValue (PARAM_P2));
    p3Val.setValue (parameterValue (PARAM_P3));
    p4Val.setValue (parameterValue (PARAM_P4));

    if (auto* p = getPlayHead())
    {
        AudioPlayHead::CurrentPositionInfo pos;
        if (p->getCurrentPosition (pos))
        {
            c = pos.timeInSeconds;
        }
    }

    for (int i = 0; i < buffer.getNumSamples(); i++)
    {
        l = lData[i];
        r = rData[i];
        
        p1 = p1Val.getNextValue();
        p2 = p2Val.getNextValue();
        p3 = p3Val.getNextValue();
        p4 = p4Val.getNextValue();

        double l2 = lParser->evaluate();
        double r2 = rParser->evaluate();
        
        if (std::isnan (l2) || std::isinf (l2)) l2 = 0.0f;
        if (std::isnan (r2) || std::isinf (r2)) r2 = 0.0f;
        
        l2 = jlimit (-1.0, 1.0, l2);
        r2 = jlimit (-1.0, 1.0, r2);
        
        lData[i] = l2;
        rData[i] = r2;
        
        if (c != -1) c = 1 / sr;
        t += 1 / sr;
        s++;
    }
}

//==============================================================================
bool MathsAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* MathsAudioProcessor::createEditor()
{
    editor = new MathsAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MathsAudioProcessor();
}
